package diag.symb.javabdd;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import lang.MMLDRule;
import lang.MMLDTransition;
import lang.YAMLDComponent;
import lang.YAMLDEvent;
import lang.YAMLDFormula;
import lang.YAMLDTrue;
import net.sf.javabdd.BDD;
import net.sf.javabdd.BDDFactory;

/**
 * A <code>LocalTransition</code>, i.e., a local transition, 
 * is an object that represents a <i>transition</i> as seen from a component.  
 * By <i>transition</i> here, we do not mean an MMLD transition 
 * but a way for the component to change state.  
 * A local transition is modeled by: 
 * <ul>
 * <li>a BDD which represents the constraints on the current state, 
 * the bddEffect on the state, and the events that take place, 
 * </li>
 * <li>the input event that can trigger this transition, 
 * <tt>null</tt> is none, 
 * </li>
 * <li>the set of output events generates by this transition.  
 * </li>
 * </ul>
 * 
 * @author Alban Grastien
 */
public class LocalTransition {
    
    /**
     * The BDD that represents this rule.  
     */
    private final BDD _bdd;
    
    /**
     * The input event (if any).  
     */
    private final YAMLDEvent _input;
    
    /**
     * The set of output events (if any).  
     */
    private final List<YAMLDEvent> _outputs;
    
    /**
     * Creates a BDD rule represented by the specified BDD, 
     * triggered by the specified input event, 
     * and generating the specified output events.  
     * 
     * @param bdd the BDD representing the rule.  
     * @param i the input event (<code>null</code> if none).  
     * @param os the output events.  
     */
    private LocalTransition (BDD bdd, YAMLDEvent i, YAMLDEvent... os) {
        _bdd = bdd;
        _input = i;
        _outputs = new ArrayList<YAMLDEvent>();
        for (final YAMLDEvent e: os) {
            _outputs.add(e);
        }
        
//        System.out.println("LT:: " + this);
    }
    
    /**
     * Creates a BDD rule represented by the specified BDD, 
     * triggered by the specified input event, 
     * and generating the specified collection of output events.  
     * 
     * @param bdd the BDD representing the rule.  
     * @param i the input event (<code>null</code> if none).  
     * @param os the output events.  
     */
    private LocalTransition (BDD bdd, YAMLDEvent i, Collection<YAMLDEvent> os) {
        _bdd = bdd;
        _input = i;
        _outputs = new ArrayList<YAMLDEvent>();
        for (final YAMLDEvent e: os) {
            _outputs.add(e);
        }
        
//        System.out.println("LT:: " + this);
    }
    
    /**
     * Returns the BDD associated with this local transition.  
     * 
     * @return the BDD that constraints the state of the component, 
     * applies the effects of the transition, and forces the events.  
     */
    public BDD getBDD() {
        return _bdd;
    }
    
    /**
     * Returns the input event that triggers this transition (if any).  
     * 
     * @return the input event of this transition if any, 
     * <tt>null</tt> otherwise.  
     */
    public YAMLDEvent getInput() {
        return _input;
    }
    
    /**
     * Returns the list of events generated by this transition.  
     * 
     * @return the list of events that this transition produces.  
     */
    public List<YAMLDEvent> getOutputs() {
        return _outputs;
    }
    
    @Override
    public String toString() {
        final StringBuilder builder = new StringBuilder();
        
        builder.append(_bdd);
        builder.append("; ");
        builder.append(_input);
        builder.append("; ");
        builder.append(_outputs);
        
        return builder.toString();
    }
    
    //
    // CREATE ALL THE RULES
    //
    
    /**
     * Computes the BDD rules of the specified component.  
     * 
     * @param frame the java BDD framework.  
     * @param comp the component.
     * @return the list of BDD rules of component <tt>comp</tt>.  
     */
    public static List<LocalTransition> rulesOfComponent(
            JavaBDDFramework2 frame, YAMLDComponent comp) {
//        System.out.println("LT::rulesOfComponent " + comp.name());
        final List<LocalTransition> result = new ArrayList<LocalTransition>();
        
        for (final MMLDTransition trans: comp.transitions()) {
            result.addAll(rulesOfTransition(frame, comp, trans));
        }
        
        return result;
    }
    
    /**
     * Computes the BDD rules of the specified transition of the specified component.  
     * 
     * @param frame the java BDD framework.  
     * @param comp the component.  
     * @param trans the transition.  
     */
    private static List<LocalTransition> rulesOfTransition(
            JavaBDDFramework2 frame, YAMLDComponent comp, MMLDTransition trans) {
//        System.out.println("LT::rulesOfTransition " + trans.getName());
        final BDDFactory fact = frame.getFactory();
        
        final List<LocalTransition> result = new ArrayList<LocalTransition>();
        
        // Input events and preconditions
        final List<YAMLDEvent> transInputs = new ArrayList<YAMLDEvent>();
        transInputs.addAll(trans.getTriggeringEvents());
        final List<YAMLDFormula> transPreconditions = new ArrayList<YAMLDFormula>();
        transPreconditions.addAll(trans.getPreconditions());
        if (transInputs.isEmpty() && transPreconditions.isEmpty()) {
            transPreconditions.add(YAMLDTrue.TRUE);
        }
        final Map<YAMLDEvent,BDD> bddInputs = new HashMap<YAMLDEvent, BDD>();
        bddInputs.put(null, fact.one());
        final List<YAMLDEvent> compOutputs = new ArrayList<YAMLDEvent>();
        {
            final Set<YAMLDEvent> compInputs = new HashSet<YAMLDEvent>();
            for (final YAMLDEvent ev: comp.events()) {
                if (ev.isInput()) {
                    compInputs.add(ev);
                } else {
                    compOutputs.add(ev);
                }
            }
            for (final YAMLDEvent ev: transInputs) {
                final Set<YAMLDEvent> otherEvents = new HashSet<YAMLDEvent>();
                otherEvents.addAll(compInputs);
                otherEvents.remove(ev);
                final BDD bddNoOtherInput = frame.bddNonOccurrence(otherEvents);
                final BDD bddInput;
                if (ev == null) {
                    bddInput = fact.one();
                } else {
                    bddInput = frame.bddEventOccurred(ev);
                }
                final BDD bddInputAndNoOther = bddNoOtherInput.and(bddInput);
                bddInputs.put(ev, bddInputAndNoOther);
            }
        }
        
        BDD disjunctionOfRulePreconditions = frame.getFactory().zero();
        for (final MMLDRule rule: trans.getRules()) {
            final BDD bddRulePrecondition = frame.formula(comp, rule.getCondition());
            final BDD bddRuleEffect = frame.bddEffect(comp, rule);
            final BDD bddOutputEvents;
            {
                BDD tmp = fact.one();
                for (final YAMLDEvent outputEvent: compOutputs) {
                    final BDD bddEventOccurred = frame.bddEventOccurred(outputEvent);
                    if (rule.isGenerated(outputEvent)) {
                        tmp = tmp.and(bddEventOccurred);
                    } else {
                        tmp = tmp.and(bddEventOccurred.not());
                    }
                }
                bddOutputEvents = tmp;
            }
            
            for (final YAMLDEvent input: transInputs) {
                final BDD bddInputEvent = bddInputs.get(input);
                final BDD bdd = bddInputEvent.and(bddOutputEvents)
                        .and(bddRulePrecondition).and(bddRuleEffect);
                final LocalTransition bddRule = new LocalTransition(bdd, input, rule.getGeneratedEvents());
                result.add(bddRule);
            }
            
            for (final YAMLDFormula transPrec: transPreconditions) {
                final BDD bddInputEvent = bddInputs.get(null);
                final BDD bddTransPrecondition = frame.formula(comp, transPrec);
                final BDD bdd = bddInputEvent.and(bddOutputEvents)
                        .and(bddRulePrecondition).and(bddRuleEffect).and(bddTransPrecondition);
                final LocalTransition bddRule = new LocalTransition(bdd, null, rule.getGeneratedEvents());
                result.add(bddRule);
            }
            
            disjunctionOfRulePreconditions = disjunctionOfRulePreconditions.or(bddRulePrecondition);
        }
        
        if (!disjunctionOfRulePreconditions.isOne()) {
            final BDD bddDefaultRulePrecondition = disjunctionOfRulePreconditions.not();
            final BDD bddStateUnchanged = frame.valueOfStateUnchanged(comp);
            final BDD bddNoOutputEvent = frame.bddNonOccurrence(compOutputs);
            for (final YAMLDEvent input: transInputs) {
                final BDD bddInputEvent = bddInputs.get(input);
                final BDD bdd = bddInputEvent.and(bddNoOutputEvent)
                        .and(bddStateUnchanged).and(bddDefaultRulePrecondition);
                final LocalTransition bddRule = new LocalTransition(bdd, null);
                result.add(bddRule);
            }
        }
        
        return result;
    }
    
    /**
     * Returns default rule for the specified component, 
     * i.e., the rule that specifies that no transition 
     * takes place on the specified component.  
     * 
     * @param frame the java BDD framework.  
     * @param comp the component.  
     * @return the default rule for <tt>comp</tt>.  
     */
    public static LocalTransition defaultRule(JavaBDDFramework2 frame, YAMLDComponent comp) {
        final BDD bdd;
        {
            //System.out.println("LT::1");
            final BDD stateUnchanged = frame.valueOfStateUnchanged(comp);
            //System.out.println("LT::1");
            final BDD noTransition = frame.bddNonOccurrence(comp.events());
            //System.out.println("LT::3");
            bdd = stateUnchanged.and(noTransition);
        }
        
        //System.out.println("LT::4");
        final LocalTransition result = new LocalTransition(bdd, null);
        return result;
    }

}
