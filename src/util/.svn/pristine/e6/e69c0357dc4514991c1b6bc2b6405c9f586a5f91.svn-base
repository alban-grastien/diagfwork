package util;

import java.util.Collection;
import java.util.List;

import lang.MMLDRule;
import lang.Network;
import lang.State;
import lang.YAMLDComponent;
import lang.YAMLDEvent;

/**
 * Abstract implementation of a scenario.  The purpose of this class 
 * is to give an implementation for the methods that can be defined 
 * from other methods of a scenario.  A Scenario class that extends 
 * this class will also implement any method added later 
 * in the Scenario interface.  
 * 
 * @author Alban Grastien
 * @version 1.0
 * */
public abstract class AbstractScenario implements Scenario {

	/**
	 * Returns the sequence of observations 
	 * generated by the specified scenario.
	 * 
	 * @param sce the scenario whose observations are extracted.  
	 * @param obs the collection of observable events.  
	 * @return the list of observable events generated 
	 * by <code>sce</code>.
	 * @deprecated
	 * */
	public static List<YAMLDEvent> observations(Scenario sce, Collection<YAMLDEvent> obs) {
		throw new UnsupportedOperationException("This method is deprecated.");
//		final List<YAMLDEvent> result = new ArrayList<YAMLDEvent>();
//		final int size = sce.nbTrans();
//		for (int i=0 ; i<size ; i++) {
//			final GlobalTransition gt = sce.getTrans(i);
//			for (final YAMLDComponent c: gt.affectedComponents()) {
//				final YAMLDTrans t = gt.getTransition(c);
//				final YAMLDEvent e = t.eventTrigger();
//				if (e == null) {
//					continue;
//				}
//				if (obs.contains(e)) {
//					result.add(e);
//				}
//			}
//		}
//		return result;
	}
	
	@Override
	@Deprecated
	public List<YAMLDEvent> observations(Collection<YAMLDEvent> obs) {
		return observations(this, obs);
	}

	/**
	 * Returns the alarm log associated with the specified scenario 
	 * provided the specified set of observable events.  
	 * 
	 * @param sce the scenario.  
	 * @param obs the set of events that should be recorded in the alarm log.  
	 * @return the alarm log of scenario <code>sce</code>.  
	 * */
	@Deprecated
	public static AlarmLog alarmLog(Scenario sce, Collection<YAMLDEvent> obs) {
		throw new UnsupportedOperationException("This implementation is no longer supported");
		// TODO: A new version using MMLD?
//		Collection<AlarmEntry> entries = new ArrayList<AlarmEntry>();
//		
//		entries.add(new AlarmEntry(sce.getTime(0)));
//		
//		boolean observedLast = true;
//		for (int i=0 ; i<sce.nbTrans() ; i++) {
//			final Collection<YAMLDEvent> events = new ArrayList<YAMLDEvent>();
//			final GlobalTransition glob = sce.getTrans(i);
//			for (final YAMLDComponent c: glob.affectedComponents()) {
//				final YAMLDTrans t = glob.getTransition(c);
//				final YAMLDEvent e = t.eventTrigger();
//				if (e == null) {
//					continue;
//				}
//				if (obs.contains(e)) {
//					events.add(e);
//				}
//			}
//
//			if (events.isEmpty()) {
//				observedLast = false;
//				continue;
//			}
//			
//			observedLast = true;
//			final double time = sce.getTime(i+1);
//			entries.add(new AlarmEntry(events, time));
//		}
//		
//		if (!observedLast) {
//			entries.add(new AlarmEntry(sce.getTime(sce.nbTrans())));
//		}
//		
//		return new ImmutableAlarmLog(entries);
	}
	
	@Override
	public AlarmLog alarmLog(Collection<YAMLDEvent> obs) {
		return alarmLog(this, obs);
	}
	
	/**
	 * Builds a sub scenario of the specified scenario 
	 * where unobservable and unnecessary transitions are removed.  
	 * (An unnecessary transition is defined as a transition 
	 * that does not have a causal link to another transition).
	 * 
	 * @param sce the scenario that is being simplified.  
	 * @return a simplified version of <code>sce</code>.  
	 * */
	public static Scenario simplify(Scenario sce) {
		final MMLDGlobalTransition[] arr = new MMLDGlobalTransition[sce.nbTrans()];
		final State[] states = new State[sce.nbTrans()+1];
		final State[] copy = new State[sce.nbTrans()+1];

		states[0] = sce.getState(0);
		final Network net = states[0].getNetwork();
		final Collection<YAMLDEvent> observableEvents = net.observableEvents();
		for (int i=0 ; i<arr.length ; i++) {
			arr[i] = sce.getMMLDTrans(i);
			states[i+1] = sce.getState(i+1);
		}
		
		for (int i = arr.length-1 ; i>= 0 ; i--) {
			// Trying to remove the ith transition
			final MMLDGlobalTransition glob = arr[i];
			{
				boolean observable = false;
				for (final YAMLDComponent c: glob.affectedComponents()) {
					final MMLDRule rule = glob.getRule(c);
					for (final YAMLDEvent evt: rule.getGeneratedEvents()) {
						if (observableEvents.contains(evt)) {
							observable = true;
							break;
						}
					}
					if (observable) {
						break;
					}
				}
				if (observable) {
					// Cannot remove it.
					continue;
				}
			}
			
			// Trying to build a scenario without this transition
			State currentState = states[i];
			copy[i+1] = currentState;
			boolean removable = true;
			for (int j=i+1 ; j<arr.length ; j++) {
				final MMLDGlobalTransition glob2 = arr[j];
				if (glob2 != null) {
					if (!currentState.isApplicable(glob2)) {
						removable = false;
						break;
					}
					currentState = currentState.apply(new TransStateModification(glob2, currentState));
				}
				copy[j+1] = currentState;
			}
			
			if (removable) {
				arr[i] = null;
				for (int j=i+1 ; j<copy.length ; j++) {
					states[j] = copy[j];
				}
			}
		}
		
		Scenario result = new EmptyScenario(states[0], Time.ZERO_TIME);
		for (int i=0 ; i<arr.length ; i++) {
			if (arr[i] != null) {
				result = new IncrementalScenario(result, arr[i], states[i+1]);
			}
		}
		
		return result;
	}
}
