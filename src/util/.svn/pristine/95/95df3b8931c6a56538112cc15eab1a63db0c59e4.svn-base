package util;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.antlr.runtime.ANTLRReaderStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;

import lang.Network;
import lang.YAMLDComponent;
import lang.YAMLDEvent;
import lang.YAMLDlightLexer;
import lang.YAMLDlightParser;

/**
 * An implementation of an alarm log.
 * 
 * @author Alban Grastien
 * */
public class ImmutableAlarmLog extends AbstractAlarmLog implements AlarmLog {

	private final List<AlarmLog.AlarmEntry> _entries;

	/**
	 * Builds an alarm log from the specified collection of entries. This
	 * constructor is more efficient if the collection is already sorted such
	 * that the {@link Iterator} returns the logs in increasing order.
	 * 
	 * @param entries
	 *            the collection of entries to put in the alarm log.
	 * */
	public ImmutableAlarmLog(Collection<AlarmLog.AlarmEntry> entries) {
		final List<AlarmLog.AlarmEntry> logs = new ArrayList<AlarmEntry>();
		boolean ordered = true;
		{
			Time currentmax = Time.ZERO_TIME;
			for (final AlarmLog.AlarmEntry entry : entries) {
				ordered = ordered && currentmax.isBefore(entry._time);
				//ordered = ordered && (currentmax < entry._time);
				currentmax = entry._time;
				logs.add(entry);
			}
		}

		if (!ordered) {
			Collections.sort(logs, new Comparator<AlarmLog.AlarmEntry>() {
				@Override
				public int compare(AlarmEntry o1, AlarmEntry o2) {
					if (o1 == o2) {
						return 0;
					}
					if (o1._time.isBefore(o2._time)) {
						return -1;
					}
					if (o1._time.isBefore(o2._time)) {
						return 1;
					}

					throw new IllegalStateException(
							"There cannot be two alarm entries with the same time.");
				}
			});
		}

		_entries = Collections.unmodifiableList(logs);
	}

	@Override
	public AlarmEntry get(int i) {
		return _entries.get(i);
	}

	@Override
	public int nbEntries() {
		return _entries.size();
	}

	/**
	 * Builds an immutable alarm log from the file at the specified address.  
	 * The format of the file should be consistent with the one 
	 * generated by {@link AlarmLog#toFormattedString()}.  
	 * 
	 * @param net the network for which the alarm log is defined.  
	 * @param ad the address of the file.  
	 * @return the immutable alarm log that was read 
	 * at address <code>ad</code> if possible, 
	 * <code>null</code> if anything wrong happened.  
	 * TODO: should return exceptions.  
	 * @see AlarmLog#toFormattedString()
	 * */
	public static ImmutableAlarmLog readLogFile(Network net, String ad) {
		try {
			final Collection<AlarmLog.AlarmEntry> entries = new ArrayList<AlarmEntry>();
			Collection<YAMLDEvent> events = null;
			double currentTime = Double.MIN_NORMAL;
			
			final Pattern patComment = Pattern.compile("^((\\s*//.*)|(\\s*))$");
			final Pattern patTime = Pattern.compile("^\\s*time\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$");
			//final Pattern patTime = Pattern.compile("^\\s*time\\s*=\\s*(\\d+)\\s*$");
			final Pattern patEvent = Pattern.compile("^\\s*(\\S+)\\s*\\.\\s*(\\S+)\\s*$");
			
			final BufferedReader reader = new BufferedReader(new FileReader(ad));
			while (reader.ready()) {
				final String line = reader.readLine();
				if (patComment.matcher(line).matches()) {
					continue;
				}
				
				{
					final Matcher mat = patTime.matcher(line);
					if (mat.matches()) {
						if (events != null) {
							entries.add(new AlarmEntry(events, new Time(currentTime)));
						}
						currentTime = Double.parseDouble(mat.group(1));
						events = new HashSet<YAMLDEvent>();
						continue;
					}
				}
				
				{
					final Matcher mat = patEvent.matcher(line);
					if (mat.matches()) {
						final YAMLDComponent comp = net.getComponent(mat.group(1));
						if (comp == null) {
							throw new IllegalStateException("Unknown component " + mat.group(1));
						}
						final YAMLDEvent event = comp.getEvent(mat.group(2));
                        if (event == null) {
                            throw new IllegalStateException("Unknown event " + mat.group(2) + " for component " + mat.group(1));
                        }
						events.add(event);
						continue;
					}
				}
				
				System.err.println("Cannot parse line " + line);
				return null;
			}
			if (events != null) {
				entries.add(new AlarmEntry(events, new Time(currentTime)));
			}
			
			try {
				return new ImmutableAlarmLog(entries);
			} catch (Exception e) {
				return null;
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return null;
	}

    @Override
    public int nbObs() {
        int result = 0;
        for (final AlarmEntry ent: this) {
            result += ent._events.size();
        }
        return result;
    }
	
	public static void main (String [] args) {
		//String filename = "/home/agrastie/projects/mbpe/eaproto/new_src/YAMLDSim/data/large_model/mod.2.yamld";
		String filename = "/home/agrastien/examples/tg2/window-347.mmld-ground";

		Network net = null;

		try {
			InputStream inputStream = new FileInputStream(filename);
			Reader input = new InputStreamReader(inputStream);
			YAMLDlightLexer lexer = new YAMLDlightLexer(new ANTLRReaderStream(
					input));
			CommonTokenStream tokens = new CommonTokenStream(lexer);
			YAMLDlightParser parser = new YAMLDlightParser(tokens);
			parser.net();

			net = YAMLDlightParser.net;
		} catch (IOException e) {
			throw new RuntimeException(e);
		} catch (RecognitionException e) {
			throw new RuntimeException(e);
		}
		
		final AlarmLog log = readLogFile(net, "/home/agrastien/examples/tg2/window-347.alarms");
		System.out.println("Printing the logs");
		System.out.println(log.toFormattedString());
	}
}
