package util;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;

import java.util.List;
import lang.YAMLDEvent;

/**
 * An alarm log is the output generated by a scenario.  
 * The log is composed of alarms entries, 
 * each entry containing a set of observable events 
 * and the time when the observation was made.  
 * In case the entry set of events is empty, 
 * no observation was made since the previous entry 
 * and before the next entry; this is particularly useful
 * to indicate that there was no more observations at the end of the logs.  
 * 
 * @author Alban Grastien
 * @version 1.0
 * */
public interface AlarmLog extends Iterable<AlarmLog.AlarmEntry> {

    /**
     * The number of alarms in this alarm log.  
     * It could be different from {@link #nbEntries() } 
     * where there to not be one alarm per entry.  
     * 
     * @return the number of alarms in this log.  
     */
    public int nbObs();
    
	/**
	 * Indicates the number of times in this log.  
	 * 
	 * @return the number of entries in this log.  
	 * */
	public int nbEntries();
	
	/**
	 * Returns the entry in the logs at the specified position.  
	 * 
	 * @param i a value between <code>0</code> and 
	 * <code>nbAlarms() -1</code>.  
	 * @return the <i>i</i>th entry in this log.  
	 * */
	public AlarmEntry get(int i);
	
	/**
	 * Returns a string representation of this alarm log.  
	 * The format of the string is the following: 
	 * <ul>
	 * <li>each entry is written on one or more lines;</li>
	 * <li>the first line of the entry described the time of the entry, 
	 * as follows: <code>time = xxx.xxx</code> or <code>time = xxx</code> 
	 * where <code>xxx.xxx</code> or <code>xxx</code> 
	 * is the double or integer representation of the entry time;</li>
	 * <li>the next lines of the entry contain all the observable events 
	 * in the entry, one per line, with the format 
	 * <code>comp_name.event_name</code>;</li>
	 * <li>blank lines and white spaces are allowed;</li>
	 * <li>comment lines start with <code>//</code>.</li>
	 * 
	 * @return a string representing this alarm log.  
	 * */
	public String toFormattedString();
	
	/**
	 * An alarm entry contains the comprehensive list of alarms 
	 * emitted at a given time.  An alarm entry is immutable.  
	 * */
	public class AlarmEntry {
		public final Time _time;
		public final Collection<YAMLDEvent> _events;
		
		/**
		 * Builds an alarm entry corresponding to the generation 
		 * of the observation of the specified event at the specified time.  
		 * 
		 * @param event the event in the alarm entry.  
		 * @param time the time when the event took place.  
		 * */
		public AlarmEntry(YAMLDEvent event, Time time) {
			_time = time;
			final Collection<YAMLDEvent> events = new ArrayList<YAMLDEvent>();
			events.add(event);
			_events = Collections.unmodifiableCollection(events);
		}
		
		/**
		 * Builds an alarm entry corresponding to the generation 
		 * of the observation of the specified collection of events 
		 * at the specified time.  
		 * 
		 * @param events the collection of events that took place.  
		 * @param time the time when the events took place.  
		 * */
		public AlarmEntry(Collection<YAMLDEvent> events, Time time) {
			this._time = time;
			this._events = Collections.unmodifiableSet(new HashSet<YAMLDEvent>(events));
		}
		
		/**
		 * Builds an alarm entry indicating that no observable event 
		 * took place at the specified time.  
		 * 
		 * @param time the time of this entry.  
		 * */
		public AlarmEntry(Time time) {
			this._time = time;
			_events = Collections.emptySet();
		}
		
		/**
		 * Returns a string representation of this entry.  
		 * The format of the string is the one described 
		 * in {@link AlarmLog#toFormattedString()}.  
		 * 
		 * @return a string representation of this entry.  
		 * */
		public String toFormattedString() {
			final StringBuilder result = new StringBuilder();
			result.append("time = ").append(_time).append("\n");
			for (final YAMLDEvent event: _events) {
				result
					.append(event.getComponent().name())
					.append(".")
					.append(event.name())
					.append("\n");
			}
			return result.toString();
		}
        
        /**
         * Returns the possible orders of the alarms in this entry.  
         * 
         * @return a collection of ordering of this entry.  
         */
        public Collection<List<YAMLDEvent>> getOrderings() {
            // The resulting collection is built incrementally
            List<List<YAMLDEvent>> result = new ArrayList<List<YAMLDEvent>>();
            result.add(new ArrayList<YAMLDEvent>());
            
            for (final YAMLDEvent event: _events) {
                result = insertInAllAtAllPositions(result, event);
            }
            
            return result;
        }
        
        /**
         * Computes the list of lists that correspond 
         * to the addition of the specified element 
         * at any position in any list of the specified collection.  
         * This is the generalisation of {@link #insertAtAllPositions(java.util.List, java.lang.Object) } 
         * where the list of elements is replaced by a collection of lists.  
         * 
         * @param currentCollection the collection of lists 
         * to which the element is to be added.  
         * @param e the element to add.  
         * @return all the possible combinations of adding <tt>e</tt> 
         * to some list of <tt>currentCollection</tt>.  
         */
        private static <E> List<List<E>> insertInAllAtAllPositions(
                Collection<List<E>> currentCollection, E e) {
            final List<List<E>> result = new ArrayList<List<E>>();
            for (final List<E> list: currentCollection) {
                final List<List<E>> newLists = insertAtAllPositions(list, e);
                result.addAll(newLists);
            }
            
            return result;
        }
        
        /**
         * Computes the list of lists that correspond 
         * to the addition of the specified element 
         * at any position in the specified list.  
         * So, for instance, if <tt>currentList = [1,2,3]</tt> 
         * and <tt>e = 4</tt>, 
         * then this method will return: 
         * <tt>[4,1,2,3],[1,4,2,3],[1,2,4,3],[1,2,3,4]</tt>.  
         * 
         * @param currentList the list to which the element is added.  
         * @param e the element to add.  
         * @return all the possible combination of adding <tt>e</tt> 
         * to <tt>currentList</tt>.  
         */
        private static <E> List<List<E>> insertAtAllPositions(
                List<E> currentList, E e) {
            final List<List<E>> result = new ArrayList<List<E>>();
            for (int position = 0 ; position <= currentList.size() ; position++) {
                final List<E> newList = new ArrayList<E>(currentList);
                newList.add(position, e);
                result.add(newList);
            }
            return result;
        }
        
        @Override
        public String toString() {
            final StringBuilder bui = new StringBuilder();
            bui.append(_events);
            bui.append("@");
            bui.append(_time);
            return bui.toString();
        }
	}
	
}
