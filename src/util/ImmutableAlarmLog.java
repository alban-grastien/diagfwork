package util;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.antlr.runtime.ANTLRReaderStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.RecognitionException;

import lang.Network;
import lang.YAMLDComponent;
import lang.YAMLDEvent;
import lang.YAMLDlightLexer;
import lang.YAMLDlightParser;

/**
 * An implementation of an alarm log.
 * 
 * @author Alban Grastien
 * */
public class ImmutableAlarmLog extends AbstractAlarmLog implements AlarmLog {

	private final List<AlarmLog.AlarmEntry> _entries;

	/**
	 * Builds an alarm log from the specified collection of entries. This
	 * constructor is more efficient if the collection is already sorted such
	 * that the {@link Iterator} returns the logs in increasing order.
	 * 
	 * @param entries
	 *            the collection of entries to put in the alarm log.
	 * */
	public ImmutableAlarmLog(Collection<AlarmLog.AlarmEntry> entries) {
		final List<AlarmLog.AlarmEntry> logs = new ArrayList<AlarmEntry>();
		boolean ordered = true;
		{
			Time currentmax = Time.ZERO_TIME;
			for (final AlarmLog.AlarmEntry entry : entries) {
				ordered = ordered && currentmax.isBefore(entry._time);
				//ordered = ordered && (currentmax < entry._time);
				currentmax = entry._time;
				logs.add(entry);
			}
		}

		if (!ordered) {
			Collections.sort(logs, new Comparator<AlarmLog.AlarmEntry>() {
				@Override
				public int compare(AlarmEntry o1, AlarmEntry o2) {
					if (o1 == o2) {
						return 0;
					}
					if (o1._time.isBefore(o2._time)) {
						return -1;
					}
					if (o1._time.isBefore(o2._time)) {
						return 1;
					}

					throw new IllegalStateException(
							"There cannot be two alarm entries with the same time.");
				}
			});
		}

		_entries = Collections.unmodifiableList(logs);
	}

	@Override
	public AlarmEntry get(int i) {
		return _entries.get(i);
	}

	@Override
	public int nbEntries() {
		return _entries.size();
	}

	/**
	 * Builds an immutable alarm log from the file at the specified address.  
	 * The format of the file should be consistent with the one 
	 * generated by {@link AlarmLog#toFormattedString()}.  
	 * 
	 * @param net the network for which the alarm log is defined.  
	 * @param ad the address of the file.  
	 * @return the immutable alarm log that was read 
	 * at address <code>ad</code> if possible, 
	 * <code>null</code> if anything wrong happened.  
	 * TODO: should return exceptions.  
	 * @see AlarmLog#toFormattedString()
	 * */
	public static ImmutableAlarmLog readLogFile(Network net, String ad) {
	    try {
		final Collection<AlarmLog.AlarmEntry> entries = new ArrayList<AlarmEntry>();
		Collection<YAMLDEvent> events = null;
		double currentTime = Double.MIN_NORMAL;
		
		final Pattern patComment = Pattern.compile("^((\\s*//.*)|(\\s*))$");
		final Pattern patTime = Pattern.compile("^\\s*time\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$");
		//final Pattern patTime = Pattern.compile("^\\s*time\\s*=\\s*(\\d+)\\s*$");
		final Pattern patEvent = Pattern.compile("^\\s*(\\S+)\\s*\\.\\s*(\\S+)\\s*$");
		
		final BufferedReader reader = new BufferedReader(new FileReader(ad));
		while (reader.ready()) {
		    final String line = reader.readLine();
		    if (patComment.matcher(line).matches()) {
			continue;
		    }
		    
		    {
			final Matcher mat = patTime.matcher(line);
			if (mat.matches()) {
			    if (events != null) {
				entries.add(new AlarmEntry(events, new Time(currentTime)));
			    }
			    currentTime = Double.parseDouble(mat.group(1));
			    events = new HashSet<YAMLDEvent>();
			    continue;
			}
		    }
		    
		    {
			final Matcher mat = patEvent.matcher(line);
			if (mat.matches()) {
			    final YAMLDComponent comp = net.getComponent(mat.group(1));
			    if (comp == null) {
				throw new IllegalStateException("Unknown component " + mat.group(1));
			    }
			    final YAMLDEvent event = comp.getEvent(mat.group(2));
			    if (event == null) {
				throw new IllegalStateException("Unknown event " + mat.group(2) + " for component " + mat.group(1));
			    }
			    events.add(event);
			    continue;
			}
		    }
		    
		    System.err.println("Cannot parse line " + line);
		    return null;
		}
		if (events != null) {
		    entries.add(new AlarmEntry(events, new Time(currentTime)));
		}
		
		try {
		    return new ImmutableAlarmLog(entries);
		} catch (Exception e) {
		    return null;
		}
	    } catch (Exception e) {
		e.printStackTrace();
	    }
	    return null;
	}

    @Override
    public int nbObs() {
        int result = 0;
        for (final AlarmEntry ent: this) {
            result += ent._events.size();
        }
        return result;
    }
	
}
